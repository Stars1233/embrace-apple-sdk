//
//  Copyright Â© 2024 Embrace Mobile, Inc. All rights reserved.
//

import Foundation
import EmbraceOTelInternal
import EmbraceCommonInternal
import CoreData

/// Class that handles all the cached upload data generated by the Embrace SDK.
class EmbraceUploadCache {

    private(set) var options: EmbraceUpload.CacheOptions
    let container: NSPersistentContainer
    let context: NSManagedObjectContext
    let logger: InternalLogger

    init(options: EmbraceUpload.CacheOptions, logger: InternalLogger) throws {
        self.options = options
        self.logger = logger

        // create core data stack
        let model = NSManagedObjectModel()
        model.entities = [UploadDataRecord.entityDescription]

        self.container = NSPersistentContainer(name: "EmbraceUploadCache", managedObjectModel: model)

        switch options.storageMechanism {
        case .inMemory:
            let description = NSPersistentStoreDescription()
            description.type = NSInMemoryStoreType
            self.container.persistentStoreDescriptions = [description]

        case let .onDisk(baseURL, _):
            try FileManager.default.createDirectory(at: baseURL, withIntermediateDirectories: true)
            let description = NSPersistentStoreDescription()
            description.url = options.fileURL
            self.container.persistentStoreDescriptions = [description]
        }

        container.loadPersistentStores { _, error in
            if let error {
                logger.error("Error initializing EmbraceUpload cache!: \(error.localizedDescription)")
            }
        }

        self.context = NSManagedObjectContext(concurrencyType: .privateQueueConcurrencyType)
        self.context.persistentStoreCoordinator = self.container.persistentStoreCoordinator
    }

    // Saves all changes on the current context to disk
    func save() {
        context.perform { [weak self] in
            do {
                try self?.context.save()
            } catch {
                self?.logger.warning("Erro saving EmbraceUploadCache: \(error.localizedDescription)")
            }
        }
    }

    /// Fetches the cached upload data for the given identifier.
    /// - Parameters:
    ///   - id: Identifier of the data
    ///   - type: Type of the data
    /// - Returns: The cached `UploadDataRecord`, if any
    public func fetchUploadData(id: String, type: EmbraceUploadType) -> UploadDataRecord? {

        var result: UploadDataRecord?
        context.performAndWait {
            do {
                let request = NSFetchRequest<UploadDataRecord>(entityName: UploadDataRecord.entityName)
                request.predicate = NSPredicate(format: "id == %@ AND type == %i", id, type.rawValue)

                result = try context.fetch(request).first
            } catch { }
        }
        return result
    }

    /// Fetches all the cached upload data.
    /// - Returns: An array containing all the cached `UploadDataRecords`
    public func fetchAllUploadData() throws -> [UploadDataRecord] {

        var result: [UploadDataRecord] = []
        context.performAndWait {
            do {
                let request = NSFetchRequest<UploadDataRecord>(entityName: UploadDataRecord.entityName)
                result = try context.fetch(request)
            } catch { }
        }
        return result
    }

    /// Removes stale data based on size or date, if they're limited in options.
    @discardableResult public func clearStaleDataIfNeeded() throws -> UInt {
        guard options.cacheDaysLimit > 0 else {
            return 0
        }

        let now = Date().timeIntervalSince1970
        let lastValidTime = now - TimeInterval(options.cacheDaysLimit * 86400) // (60 * 60 * 24) = 86400 seconds per day
        let recordsToDelete = fetchRecordsToDelete(dateLimit: Date(timeIntervalSince1970: lastValidTime))
        let deleteCount = recordsToDelete.count

        if deleteCount > 0 {
            let span = EmbraceOTel().buildSpan(
                name: "emb-upload-cache-vacuum",
                type: .performance,
                attributes: ["removed": "\(deleteCount)"])
                .markAsPrivate()
            span.setStartTime(time: Date())

            let startedSpan = span.startSpan()
            deleteRecords(recordsToDelete)
            startedSpan.end()

            return UInt(deleteCount)
        }

        return 0
    }

    /// Saves the given upload data to the cache.
    /// - Parameters:
    ///   - id: Identifier of the data
    ///   - type: Type of the data
    ///   - data: Data to cache
    /// - Returns: Boolean indicating if the operation was successful
    @discardableResult func saveUploadData(id: String, type: EmbraceUploadType, data: Data) -> Bool {

        // update if it already exists
        if let record = fetchUploadData(id: id, type: type) {
            context.perform { [weak self] in
                record.data = data
                self?.save()
            }

            return true
        }

        // check limit and delete if necessary
        checkCountLimit()

        // insert new
        var result = true

        context.performAndWait {
            let record = UploadDataRecord.create(
                context: context,
                id: id,
                type: type.rawValue,
                data: data,
                attemptCount: 0,
                date: Date()
            )

            do {
                try context.save()
            } catch {
                context.delete(record)
                result = false
            }
        }

        return result
    }

    // Checks the amount of records stored and deletes the oldest ones if the total amount
    // surpasses the limit.
    func checkCountLimit() {
        guard options.cacheLimit > 0 else {
            return
        }

        context.perform { [weak self] in
            guard let strongSelf = self else {
                return
            }

            do {
                let request = NSFetchRequest<UploadDataRecord>(entityName: UploadDataRecord.entityName)
                let count = try strongSelf.context.count(for: request)

                if count >= strongSelf.options.cacheLimit {
                    request.sortDescriptors = [NSSortDescriptor(key: "date", ascending: true)]
                    request.fetchLimit = max(0, count - Int(strongSelf.options.cacheLimit) + 10)

                    let result = try strongSelf.context.fetch(request)
                    for uploadData in result {
                        strongSelf.context.delete(uploadData)
                    }

                    strongSelf.save()
                }
            } catch { }
        }
    }

    /// Deletes the cached data for the given identifier.
    /// - Parameters:
    ///   - id: Identifier of the data
    ///   - type: Type of the data
    func deleteUploadData(id: String, type: EmbraceUploadType) {
        guard let uploadData = fetchUploadData(id: id, type: type) else {
            return
        }

        deleteUploadData(uploadData)
    }

    /// Deletes the cached `UploadDataRecord`.
    /// - Parameter uploadData: `UploadDataRecord` to delete
    func deleteUploadData(_ uploadData: UploadDataRecord) {
        context.perform { [weak self] in
           self?.context.delete(uploadData)
        }
    }

    /// Updates the attempt count of the upload data for the given identifier.
    /// - Parameters:
    ///   - id: Identifier of the data
    ///   - type: Type of the data
    ///   - attemptCount: New attempt count
    /// - Returns: Returns the updated `UploadDataRecord`, if any
    func updateAttemptCount(
        id: String,
        type: EmbraceUploadType,
        attemptCount: Int
    ) {
        guard let uploadData = fetchUploadData(id: id, type: type) else {
            return
        }

        context.perform { [weak self] in
            uploadData.attemptCount = attemptCount
            self?.save()
        }
    }

    /// Fetches all records that should be deleted based on them being older than the passed date
    func fetchRecordsToDelete(dateLimit: Date) -> [UploadDataRecord] {

        var result: [UploadDataRecord] = []
        context.performAndWait {
            do {
                let request = NSFetchRequest<UploadDataRecord>(entityName: UploadDataRecord.entityName)
                request.predicate = NSPredicate(format: "date < %@", dateLimit as NSDate)

                result = try context.fetch(request)
            } catch { }
        }
        return result
    }

    /// Deletes requested records from the database
    func deleteRecords(_ records: [UploadDataRecord]) {
        context.perform { [weak self] in
            for record in records {
                self?.context.delete(record)
            }

            self?.save()
        }
    }
}
